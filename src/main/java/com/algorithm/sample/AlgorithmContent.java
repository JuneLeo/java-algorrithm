package com.algorithm.sample;

public class AlgorithmContent {
    // 算法
    // 先序遍历，中序遍历，后序遍历，层级遍历
    // 冒泡排序：相邻两个比较，直到排序完成
    // 选择排序：选择一个最小的，和第一个交换
    // 插入排序：从第二个开始，和数组中前面的所有数值比较且插入
    // 希尔排序：切成两段，两段进行比较，然后进行插入排序
    // 堆排序：每次将构建一个最大堆顶，将堆顶与数组中最后一个元素交换 （树构建最大堆顶的时间复杂度为logN）；堆排序，每个子结点的的值都大于或者小雨左右结点值
    // 快速排序：找一个key，j从右边开始找一个比key小的值，i从左边找一个大于key的值，交换，如果i和j相遇，则交换key和j
    // 归并排序：将数组分解至2个元素，2个元素比较大小交换，然后再两两合并；最后归并是从两个有序的数组组合为1个有序数组




    // 树
    // 完全二叉树：只有最下面2层的结点的度数小于2，且最下面一层的结点都集中在该层最左边
    // 满二叉树：如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。
    //





}
